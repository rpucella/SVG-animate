<html>
  <head>

    <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>

    <script>
      


window.addEventListener("load",run);


function mkBehavior (type,stream) {
    return {type:type, stream:stream};
}

function isBehavior (b) {
    return (typeof b === "object" && "type" in b && "stream" in b);
}

// types: scalar, array
//    

var time = mkBehavior("scalar",function(t) { return t; });


// function time (t) { return t; }


function faster (r,s) {
    var ls = lift(s);
    var lr = lift(r);
    return mkBehavior(ls.type,function (t) { return ls.stream(t * lr.stream(t)); });
}


// this will fail if 'v' is an array, but that's okay because that would be
// cheating (faking an overalp with an array of scalars?)

function lift (v) { 
  return isBehavior(v) ? v : mkBehavior("scalar",function(t) { return v; });
}



/*
 * Format function
 *
 * Use %as placeholder
 *
 */

(function(){

    function fmt () {
	var i = 0, args = arguments;
	return this.replace(/%/g, function () {
	    return typeof args[i] != 'undefined' ? args[i++] : '';
	});
    }

    if (!String.fmt) {
	String.prototype.fmt = fmt
    }
})();



//
// TODOs:
// 
// - record initial transform so that we can keep it around even 
//   after we wipe everything out because of a new tag
// - make sure rotate/translate and later scale can handle
//   (recursive) arrays of nodes as well
// - rename rot/trans to rotate/translate
// - implement scaling
//


function rotate_nodes (nodes,deg,rx,ry) {
    nodes.forEach(function(node) {
	var s = d3.select(node);
	if (s.property("svg-animation-tag") != tag) {
	    ///console.log("rotate - new tag",tag,"replacing",s.property("svg-animation-tag"));
	    s.property("svg-animation-tag",tag);
	    s.attr("transform","rotate(%,%,%)".fmt(deg,rx,ry));
	} else {
	    var t = s.attr("transform")
	    ///console.log("rotate - existing tag",tag,"adding to",t);
	    s.attr("transform","rotate(%,%,%) %".fmt(deg,rx,ry,t));
	}
    })
}

function rotate_node (node,deg,rx,ry) {
    ///console.log(node,deg,rx,ry);
    var s = d3.select(node);
    if (s.property("svg-animation-tag") != tag) {
	///console.log("rotate - new tag",tag,"replacing",s.property("svg-animation-tag"));
	s.property("svg-animation-tag",tag);
	s.attr("transform","rotate(%,%,%)".fmt(deg,rx,ry));
    } else {
	var t = s.attr("transform")
	///console.log("rotate - existing tag",tag,"adding to",t);
	s.attr("transform","rotate(%,%,%) %".fmt(deg,rx,ry,t));
    }
}


function translate_nodes (nodes,x,y) {
    ///console.log("translate_nodes / nodes = ",nodes);
    nodes.forEach(function(node) { 
	var s = d3.select(node.elt);
	if (+s.property("svg-animation-tag") !== tag) {
	    s.property("svg-animation-tag",tag);
	    ///console.log("translate - new tag",tag,"replacing",s.property("svg-animation-tag"));
	    s.attr("transform","translate(%,%)".fmt(x,y));
	} else {
	    var t = s.attr("transform")
	    ///console.log("transform - existing tag",tag,"adding to",t);
	    s.attr("transform","translate(%,%) %".fmt(x,y,t));
	}
    })
}

function translate_node (node,x,y) {
    var s = d3.select(node);
    if (+s.property("svg-animation-tag") !== tag) {
	s.property("svg-animation-tag",tag);
	///console.log("translate - new tag",tag,"replacing",s.property("svg-animation-tag"));
	s.attr("transform","translate(%,%)".fmt(x,y));
    } else {
	var t = s.attr("transform")
	///console.log("transform - existing tag",tag,"adding to",t);
	s.attr("transform","translate(%,%) %".fmt(x,y,t));
    }
}


function add (s1,s2) { 
    var ls1 = lift(s1);
    var ls2 = lift(s2);
    return mkBehavior("scalar",function(t) { return ls1.stream(t) + ls2.stream(t); });
}

function mult (s1,s2) { 
    var ls1 = lift(s1);
    var ls2 = lift(s2);
    return mkBehavior("scalar",function(t) { return ls1.stream(t) * ls2.stream(t); });
}

function apply (f,s) {
    var ls = lift(s);
    return mkBehavior("scalar",function(t) { return f(ls.stream(t)); });
}

var animId = 0;


// DIRTY DIRTY HACK!
var tag;

function animate (s,duration) { 

    if (animId !== 0) {
	cancelAnimationFrame(animId);
	animId = 0;
    }

    var start = performance.now();
    var now;

    var liftedS = lift(s);

    var goWithDuration = function() { 
	///console.log("--------------------");
	now = performance.now()-start;
	tag = now;
	if (now < duration) { 
	    liftedS.stream(now);
	    animId = requestAnimationFrame(goWithDuration);
	} else {
	    console.log("BUSTED!");
	}
    }

    var go = function() { 
	///console.log("--------------------");
	now = performance.now()-start;
	tag = now;
	liftedS.stream(now);
	animId = requestAnimationFrame(go);
    }

    if (undef(duration)) { 
	go();
    } else {
	goWithDuration();
    }

}

function stop () {
    if (animId !== 0) {
	cancelAnimationFrame(animId);
	animId = 0;
    }
}

function print (s) { 
    return function(t) { console.log("@",t,"=",s.stream(t)); };
}

var test = print(apply(function(x) { return x*2;},time));
var deg = apply(function(x) { return x % 360; },time);

function undef (x) { 
    return typeof x === "undefined";
}


// cx and cy should themselves be behaviors as well

function rotate (nodes,s,cx,cy) { 
    var nodes = lift(nodes);
    var ls = lift(s);
    var process_node = function(n,angle) { 
	var x = undef(cx) ? n.x : cx;
	var y = undef(cy) ? n.y : cy;
	rotate_node(n.elt, angle, x, y);
	return n;
    }
	
    ///console.log(nodes);
    return mkBehavior(nodes.type,
		      function(t) { 
			  var angle = ls.stream(t);
			  if (nodes.type==="scalar") {
			      return process_node(nodes.stream(t),angle);
			  } else {
			      return nodes.stream(t).map(function(n) { return process_node(n,angle); });
			  }
		      });
}

// faster to skip the maps and construct this from scratch
// with a one-node translate_node?
//  (similar for rotate)

function translate (nodes,x,y) { 
    var lnodes = lift(nodes);
    var lx = lift(x);
    var ly = lift(y);
	
    return mkBehavior(nodes.type,
		      function(t) { 
			  var dx = lx.stream(t);
			  var dy = ly.stream(t);
			  var ns = lnodes.stream(t);
			  if (lnodes.type==="scalar") {
			      translate_node(ns.elt,dx,dy);
			      return ns;
			  } else {
			      ns.forEach(function(n) { return translate_node(n.elt,dx,dy); });
			      return ns;
			  }
		      });
}

var wiggle = mkBehavior("scalar", function (t) { return Math.sin(t); });
var waggle = mkBehavior("scalar", function (t) { return Math.cos(t); });

function element (id,orig_x,orig_y) { 
    var e = document.getElementById(id);
    return mkBehavior("scalar",function(t) { return {elt:e, x:orig_x, y:orig_y};  });
}


// FIXME
function threshold (s1,thres,s2) {
    return function(t) { 
	if (t<thres) {
	    return s1(t);
	} else {
	    return s2(t-thres);
	}
    }
}


// invariant: every behavior is a function that returns a value of the 
// appropriate shape (based on the constructor's inputs)

function overlap () {
    var args = [];

    for (var i=0; i<arguments.length; i++) {
	///console.log("argument",i,"=",arguments[i]);
	args.push(lift(arguments[i]));
    }

    ///console.log(args);
    
    temp =  mkBehavior("array",
		      function(t) { 
			  ///console.log("OVERLAP");
			  ///console.log("args=",args);
			  ///console.log("args[0].stream(t)=",args[0].stream(t));
			  var result = args.map(function(s) { return s.stream(t); });
			  ///console.log(result);
			  return result;
			  /*	var results = [];
	args.forEach(function(s,i) { results[i]=s(t); });
	///console.log(results);
	return results; */
		      });

    return temp;
}


function delay (d,s) { 
    var ls = lift(s)
    return mkBehavior(ls.type,
		      function(t) { 
			  if (t < d) {
			      return;
			  }
			  return ls.stream(t-d);
		      });
}


function rampTo (n,d) { 
    return mkBehavior("scalar",
		      function(t) { 
			  if (t<d) { 
			      return (n*t/d);
			  }
			  return n;
		      });
}


function spin (e,s) {
    return faster(s,rotate(e,deg));
}


// invariant: 
//  time is always local to a behavior
//  behavior always starts @ t = 0

function run () { 

    console.log("Ready to animate");

/*    var rotR1 = faster(2,rotate(element("r1",200,200),deg)); */

    var rotR2 = faster(0.30,rotate(element("r2",750,250),mult(-1,deg)));

/*    var circR1 = threshold(translate(rotR1,
				 mult(rampTo(100,1000),faster(0.001,wiggle)),
				 mult(rampTo(100,1000),faster(0.001,waggle))),
			   5000,
			   translate(rotR1,
				 faster(add(0.001,rampTo(0.001,1000)),mult(100,wiggle)),
				 faster(add(0.001,rampTo(0.001,1000)),mult(100,waggle))));
*/

/*
    var circR1 = translate(faster(0.3,rotate(element("r1",250,250),deg)),
		       mult(rampTo(100,1000),faster(0.005,wiggle)),
		       mult(rampTo(100,1000),faster(0.005,waggle)));

    var t = overlap(delay(1000,circR1),rotR2);

    t = overlap(t,rotate(translate(spin(element("r3",500,250),1),
			 faster(0.003,mult(200,wiggle)),
			 faster(0.003,mult(50,waggle))),
		   faster(0.005,deg),
		   500,250));
*/

    var orbit1 = element("c1",500,250);
    var orbit2 = faster(0.01,translate(element("c2",500,250),
				       mult(25,wiggle),
				       mult(60,waggle)));

//    var orbit = overlap(orbit1, orbit2);

    var pendulum = function(x) { return translate(x,faster(0.002,mult(200,wiggle)),0); }

    t = overlap(rotate(pendulum(orbit1),faster(0.02,mult(-1,deg)),500,250),
		rotate(pendulum(orbit2),faster(0.02,mult(-1,deg)),500,250));

//    t = rotate(pendulum(overlap(orbit1,orbit2)),
//	       faster(0.02,mult(-1,deg)),
//	       500,250);

//    t = pendulum(overlap(orbit1,orbit2));

//    t = pendulum(orbit2); // overlap(orbit1,orbit2);
			

//    t = pendulum(element("c1",500,250));
//    t = rotate(element("r3",500,250),faster(0.5,deg));

//    t = pendulum(overlap(t,orbit2))

//    t = pendulum(overlap(orbit1,orbit2));

    // this doesn't work as advertised
    // probably because the center of rotation is affected - maybe?
    t = pendulum(rotate(pendulum(overlap(orbit1,orbit2)),
			faster(0.02,mult(1,deg)),
			500,250));

    animate(t)  // ,6000);
}
      
    </script>
  </head>
  <body>
    <svg width="1000" height="500" style="border: 1px solid grey;">
        <rect id="r1" x="200" y="200" height="100" width="100" fill="red" />
        <rect id="r2" x="700" y="200" height="100" width="100" fill="blue" />
        <rect id="r3" x="450" y="230" width="100" height="40" fill="green" />

	<circle id="c1" cx="500" cy="250" r="20" fill="grey" />
	<circle id="c2" cx="500" cy="250" r="5" fill="black" />
    </svg>

  </body>
</html>
